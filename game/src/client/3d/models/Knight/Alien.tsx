/*
auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import React, { useRef, useState, useEffect, useMemo } from "react";
import {
  GroupProps,
  ThreeElements,
  useFrame,
  useGraph,
} from "@react-three/fiber";
import { useGLTF } from "@react-three/drei";
import * as THREE from "three";
import {
  AnimationAction,
  AnimationMixer,
  Bone,
  Group,
  LoopOnce,
  MeshToonMaterial,
  SkinnedMesh,
} from "three";
import { hexStringToCode } from "../../../utils/color";
import { GLTF, SkeletonUtils } from "three/examples/jsm/Addons.js";
import { mergeRefs } from "react-merge-refs";

const redMaterial = new MeshToonMaterial({
  color: hexStringToCode("#45555a"),
  // skinning: true,
});
redMaterial.color.convertSRGBToLinear();

const detailMaterial = new MeshToonMaterial({
  color: hexStringToCode("#ffffff"),
  // skinning: true,
});
detailMaterial.color.convertSRGBToLinear();

const skinMaterial = new MeshToonMaterial({
  color: hexStringToCode("#131313"),
  // skinning: true,
});
skinMaterial.color.convertSRGBToLinear();

const armorMaterial = new MeshToonMaterial({
  color: hexStringToCode("#a3a300"),
  // skinning: true,
});
armorMaterial.color.convertSRGBToLinear();

const armorDarkMaterial = new MeshToonMaterial({
  color: hexStringToCode("#3e3e00"),
  // skinning: true,
});
armorDarkMaterial.color.convertSRGBToLinear();

type ActionName =
  | "Idle"
  | "PickUp"
  | "Punch"
  | "RecieveHit"
  | "Run"
  | "SitDown"
  | "Walk";
type GLTFActions = Record<ActionName, AnimationAction>;

const NPCCharacter = React.forwardRef(
  (
    {
      moving,
      recharging,
      running,
      lastDamaged,
      lastAttack,
      ...props
    }: JSX.IntrinsicElements["group"] & {
      moving: boolean;
      recharging: boolean;
      running: boolean;
      lastDamaged: number;
      lastAttack: number;
    },
    ref
  ) => {
    const group = useRef<Group>(null);

    const { animations, scene } = useGLTF("/Alien.glb");
    const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
    const { nodes } = useGraph(clone);

    const actions = useRef<GLTFActions>();
    const [mixer] = useState(() => new AnimationMixer(nodes["Cube004_4"]));

    const currentAnimationRef = useRef<{
      key: string | null;
      animation: any;
      finished: boolean;
    }>({
      key: null,
      animation: null,
      finished: false,
    });

    useFrame((state, delta) => mixer.update(delta));
    useEffect(() => {
      if (group.current) {
        actions.current = {
          Idle: mixer.clipAction(animations[0], group.current),
          PickUp: mixer.clipAction(animations[1], group.current),
          Punch: mixer.clipAction(animations[2], group.current),
          RecieveHit: mixer.clipAction(animations[3], group.current),
          Run: mixer.clipAction(animations[4], group.current),
          SitDown: mixer.clipAction(animations[5], group.current),
          Walk: mixer.clipAction(animations[6], group.current),
        };
        actions.current.Punch.loop = LoopOnce;
        actions.current.Punch.clampWhenFinished = true;
        actions.current.Punch.timeScale = 1.2;
        actions.current.RecieveHit.loop = LoopOnce;
        actions.current.RecieveHit.clampWhenFinished = true;
        actions.current.RecieveHit.timeScale = 1.2;
        actions.current.SitDown.loop = LoopOnce;
        actions.current.SitDown.clampWhenFinished = true;
        return () => animations.forEach((clip) => mixer.uncacheClip(clip));
      }
    }, []);

    useEffect(() => {
      let unsubscribe = () => {};

      const calculateAnimation = () => {
        if (!actions.current) return;

        const currentAnimation = currentAnimationRef.current;

        const duration = 0.2;
        const quickDuration = 0.05;

        const playAnimation = (
          animation: any,
          fadeInDuration: number,
          fadeDuration: number,
          key: string | null
        ) => {
          if (currentAnimation.animation) {
            currentAnimation.animation.fadeOut(fadeDuration);
          } else {
            fadeInDuration = 0;
          }
          animation.reset().setEffectiveWeight(1).fadeIn(fadeInDuration).play();
          currentAnimation.animation = animation;
          currentAnimation.key = key;
          currentAnimation.finished = false;
        };

        const isHit = lastDamaged > Date.now() - 100;
        const isAttacking = lastAttack > Date.now() - 100;
        const attackKey = lastAttack.toString();
        const hitKey = lastDamaged.toString();

        const processAnimation = (key: string, animation: any) => {
          if (!actions.current) return;

          if (currentAnimation.animation && currentAnimation.key === key) {
          } else {
            playAnimation(animation, quickDuration, quickDuration, key);
          }

          const onFinished = (event: any) => {
            mixer.removeEventListener("finished", onFinished);
            if (actions.current && event.action === animation) {
              currentAnimation.finished = true;
              calculateAnimation();
            }
          };

          mixer.addEventListener("finished", onFinished);

          unsubscribe = () => {
            mixer.removeEventListener("finished", onFinished);
          };
        };

        if (
          isAttacking ||
          (currentAnimation.key === attackKey && !currentAnimation.finished)
        ) {
          processAnimation(attackKey, actions.current.Punch);
        } else if (
          isHit ||
          (currentAnimation.key === hitKey && !currentAnimation.finished)
        ) {
          processAnimation(hitKey, actions.current.RecieveHit);
        } else if (recharging) {
          processAnimation("recharging", actions.current.SitDown);
        } else {
          if (moving) {
            if (running) {
              playAnimation(actions.current.Run, duration, duration, null);
            } else {
              playAnimation(actions.current.Walk, duration, duration, null);
            }
          } else {
            playAnimation(actions.current.Idle, duration, duration, null);
          }
        }
      };

      calculateAnimation();

      return () => {
        unsubscribe();
      };
    }, [moving, recharging, running, lastAttack, lastDamaged]);
    return (
      <group
        ref={mergeRefs([group, ref])}
        {...props}
        dispose={null}
        scale={1.5}
      >
        <primitive object={clone} />
      </group>
    );
  }
);

export default NPCCharacter;

useGLTF.preload("/Robot.glb");
